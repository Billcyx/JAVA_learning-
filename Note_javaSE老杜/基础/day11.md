null pointer exception : 空指针异常， 运行时候出现的错误

没有被访问到的对象会被java中的 garbage collection收走； java中的GC主要针对回收的是堆内存

add(i) 指将main里面的i复制一份传递给add这个方法里面的局部变量，但是main里面的i的值是不会因为add（i）所改变的，除非 i = add（i）where add(i) return 一个新的数值。

构造方法：创建对象并且为对象属性赋值；当一个类没有提供构造方法，系统实际上会自动给student提供一个无参数的构造方法；

构造方法的语法结构： 修饰符列表（不能写static,变是public） + 构造方法名（必须和类名一致）（形式参数列表）{ 构造方法体 }

如果手动创造一个构造方法，系统将不再提供无参数构造；构造方法也可以方法重载

实质上，构造方式是在堆内存里面为类的属性和方法开辟空间。

封装的作用： 1.保护内部结构 （保护内部安全信息） 2.让使用方法简单化（方便外部人员类体调用）

随意对类体数据进行访问，这个时候信息是暴露的，会导致信息被篡改，不安全

如何封装？ 修饰词：private (e.g. private int age)，然后用get和set方法来提供操作入口，并且由于是面向对象的，所以不要带static

属于类的特征，用static（静态变量），属于对象个人独有的特征，不用static（实例变量）

静态变量储存在方法区

引用.静态变量 这里即使引用是null 也不会出现空指针异常。

静态代码块：
static {
	
} 在类加载的时候按照自上而下的顺序执行，并且只执行一次， 在main方法之前执行；一般相当于记录class产生的时间（为程序员定制的）

实例语句在构造方法执行之前执行，这也是为程序员准备的，用来记录对象构建的时机，或者是用来把不同构造方法里面相同的java语句调到构造方法外面，作为实例语句先执行

this 是一个变量，一个引用，指向自身；存在堆内存里面；this 只能使用在实例方法种；this指的是当前对象；this很多时候都是可以省略的，但是在实例方法和构造方法中，为了区分实例变量和局部变量，this这个时候是不省略的 e.g. this.name( 实例变量) = name（局部变量）；this 还可以用来从当前的构造方法中去调用另外一个构造方法，使代码更加简洁（e.g. this(1997,2,3),只不过this这个语句必须是构造方法中的第一个语句 ）

1. 任何时候都要封装； 2. 调用方法时候不要忘记打括号，即使里面没有实例变量（成员变量）. e.g. A.getName();

extends: 子类继承父类所有东西，除了父类的构造方法





























