子类继承父类以后，父类代码直接归为子类。

什么时候能继承？ 子类 is a 父类

当源码中方法以“；”结尾，并且有native修饰词，说明是调用底层C++写的dll程序

子类 继承 父类 有些方法可能需要改进，我们需要在子类重新写这个方法（所有的返回值，方法名，形式参数列表都要一致），override；方法重写时候，protected(父类) 可以改成 public（子类），但 public不能改成protected；重写之后不能抛出更多的异常；

注意：方法覆盖只针对方法，不针对属性；私有方法无法覆盖；构造方法不能够被继承；方法覆盖只针对实例方法，静态方法没有意义：静态方法是依靠类调用的，与对象无关


父类型的引用允许指向子类型的对象（编译时看 父类.class, 运行时看 子类.class, 多态的根本原因: 不同子类虽然有着相同名字的方法，但这些方法有不同内容，而这些内容在运行展示出来，但首先要依靠的父类的相同名字的方法来通过编译）

引用类型转换只有向上转换（子类-》父类）和向下转换（父类—〉子类）这两种说法

animal——》cat  Animal cat = new Cat(); cat.move(); 这里，编译器只知道 cat 是animal类型，所以会去 animal.class去找move。语法正确，编译就会成功，这里属于静态绑定；但是运行不一样，运行时回去堆内存里面去找对象，发现对象是一只猫，所以运行会去cat.class里面找move，属于动态绑定 ；但如果想要使用子类都有的技能，就要用 cat x = (cat) cat 来强制把cat从animal类型转化成cat类型。（又称向下转换）

ClassCastException:类型转换异常

c instanceof(运行阶段判断c是否是 制定类型，是return true，不是就return false； in other words, instanceof 判断引用指向的对象类型)；程序员好习惯：向下转换时，一定要用instanceof进行判断

OCP原则：修改代码时，修改的越少越好

多态的作用：降低耦合度，提高扩展力

super() 在子类种调用父类的无参数构造； super(参数)：指的是在子类中调用父类的有参数构造方法，super(）一般是默认存在的

通过super（parameters）这种方法，可以在子类构造方法中访问父类中private的参数。

子类跟父类有同名实例变量或者实例方法的时候，不能省略

![[子类和父类.png]]

super不指向任何对象，和this不一样，不是引用。super只是代表当前子类中的父类特征。

说白了 三种：super( 实参)：调用父类构造方法（只能出现在构造方法第一行）； super.name（访问父类属性); super.move() (访问父类方法)

















