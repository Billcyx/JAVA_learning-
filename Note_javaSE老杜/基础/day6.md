整数型的字面量再java被默认当成int处理，如果想转换成long，需要在数字后面加L。 for example, 300L.

大容量不能转成小容量（e.g. long不能转换成int，编译会报错）要想编译通过，必须要 强制类型转换符，只不过这个过程会损失精度。（强制类型转换符，（int）x where x is long类型）。强转的底层原理是直接看前面字节。

BUT，如果没有超出数值范围，大容量转换成小容量类型也是可以的。 e.g. byte x = 127 编译和运行是可以成功的.

二进制的补码形式：这种形式存储效率最高； 二进制有原码 反码 补码 。 对于正数，这三个数相同； 对于负数来说，不一样 （反码：符号位不变，其他位变反；补码 ：反码+1）千万要注意，计算机存储的永远是补码 形式

各种类型做混合运算时，会转换成最大容量的类型。 e.g. long + int + char = long ; 但是，如果是byte，short 或者char，这三个做混合运算则会转换成long.

interesting，编译器不知道加法运算的结果，只知道运算结果的类型是int。 怎么办呢？ 可以这样 ,
short a = （short）（'x' + 1 where x is a character）

!!!编译器只检查语法，运行才开始赋值 e.g. byte = 1 可以，但是 int a=1, byte= a, 这样不行. 因为编译器只知道a的类型，不知道a 的大小。也就是说，a的值是否是在 1 byte范围之内，编译器是不知道的。

float 和 double 存储数据 存储的 都是近似值.

float虽然是4个字节，但由于底层原理很复杂，实际上容量比long要大。 事实上，任意一个浮点数容量都比整数型空间大。

java中规定，任何一个浮点数都是被当成double来处理。如果你想要它被当作float处理，这样需要在数字尾部加F/f。

boolean只有true和false，没有别的，在java中不能用1和0来表示

#运算符
++ 出现在变量 还是变量后 都是一样的，都会导致变量+1； 但是，区别就是，当++出现在变量后，会先做赋值变换，再做++运算。e.g. n = m++ ---> n = m, m = m+1

c++; 相当于 temp = c++; if c = 80, here temp = 80, c = 81.

注意，关系运算符，两个符号之间不能有空格。

短路现象：当左边为false，短路与&&右边表达式不执行；当左边为true，短路或右边表达式不执行。因此大部分开发都用短路与&&，只有少部分时候采用与&。

i+= 10 和 i = i + 10 不一样.....，只能说相似。 如果 i 是 short， 那 i = i + 10 无法编译成功

因此，使用扩展赋值运算符时，变量的类型永远不会变。if x is byte, x += 20 相当于 x = (byte)(x + 20). 扩展赋值运算符主要是为了方便开发。

条件运算符（三目运算符）布尔表达式 ？ 表达式1 ： 表达式2

当+ 运算符任意一遍是字符串，那么这个+运算符会进行拼接操作。

当表达式有多个加号的时候，自左向右运行













