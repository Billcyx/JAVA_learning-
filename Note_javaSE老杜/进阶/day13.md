实例变量如果有final修饰，程序员必须手动赋值，这个手动赋值，在变量后面赋值可以，在构造方法中赋值也可以

实例变量用final修饰了，说明这是不会随着对象变化而变化，因此一般这个可以当作静态变量，也就是static final一起修饰，这个变量被称为常量，一般用大写 e.g.CHINESE. 常量一半又是public（因为封装没有意义），所以经常是public static final

![[抽象类.png]]

类与类之间的共同特征提取出来，就是 抽象类。 类到对象是实例化，对象到类是抽象。 类本身是不存在的，所以抽象类无法创造对象。

抽象类定义： [修饰词列表] abstract class 类名{
	类体；
}

抽象类是被子类继承的，因为抽象类无法创造对象

抽象方法：没有实现的方法，以分号结尾；有abstract关键词；抽象方法只能写在抽象类里面

子类继承抽象类，必须要重写抽象的方法

接口：接口是完全抽象的，是一种引用数据类型；抽象类是半抽象，而接口是一种特殊的抽象类。 [修饰词列表] interface 接口名{}

接口支持多继承 interfance A extends B, C{}

接口中只有常量 和 抽象方法； 接口中所有方法的都是public的； 接口中的抽象方法可以去掉public astract； 常量的 public static final 可以省略； 

类与类之间是继承，类与接口之间是实现，实现使用implements； 当一个非抽象的类连接接口时，要将接口中所有的抽象方法实现，才能正常编译和运行

一个类可以同时实现多个接口。

接口与接口之间，没有继承关系，也可以强转

调用其他接口的方法，你需要转化成别的接口

继承和实现可以同时出现： class cat *extends* animals  *implements* fly

调用者调用接口，实现者编写接口，接口解除了调用者和实现者之间的耦合（例如，顾客和厨师之间的接口是菜单）

在软件开发中，接口是核心，将项目分离不同的模块，不同模块由接口衔接；因此，项目开发中最难的是定接口的人。接口确定了之后，再由实现者实现和被调用者调用。

is a (extends)， has a (调用)， like a(实现，implements)

javac -d(指带包编译) .(点指编译生成的文件被放到当前目录下) HelloWorld.java

如果两个类不在同一个package里面，要想调用另一个package里面的类，需要import这个package。

注意 import 关键词 必须写在 package关键词 下面

import可以采用星号的方式

但是，java lang包里面的一些package是不需要import的

默认只能在本类，同包中访问
默认只能在本类，同包 子类!中访问

![[访问权限排列.png]]

类和接口 只能用public或者默认（除非是内部类where四种访问权限都可以)，至于方法或者属性 4个访问权限都可以

API: sun公司提前写好的类库就是API

toString() 目的是把java对象 转化成 字符串

string类里面已经重写了equals方法和to string方法；因为string是一个类，所以string也有方法

java中所有基本数据类型用== 判断相等， 所有引用数据类型，用equals

protected void finalize() { } throws Throwable {} 这段代码相当于垃圾回收时的系统提示。。对程序员的提示； finalize不需要主动调用，只需要有需求的时候重写方法体；这个方法自从jdk9开始就过时了

System.gc() 只是建议启动垃圾回收站

HashCode: 用哈希算法将java对象的内存地址转换成一串数字

内部类：三种内部类：静态内部类；动态内部类；局部内部类(有点不同，这个类在方法里面)： class inside class

匿名内部类 是 局部内部类 的一种，因为没有摸名字而得名 new 接口名（）{} 后面这个大括号直接相当于匿名内部类，也就是直接表明接口名的实现方； 不过不建议这样写，因为这样写看起来1. 很复杂 2.类没有名字，没有可重复性。














































